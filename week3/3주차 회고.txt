우아한테크코스 프리코스 3주차 회고

이창근


---

# 3주차에 했던 고민들

3주차의 학습목표는 도메인과 단위테스트였는데, 저는 좋은 단위테스트는 좋은 설계에서 출발한다고 생각합니다. 그래서 단위테스트를 작성하기에 앞서 도메인과 설계에 대한 고민들이 정말 많았고, 그 고민 지점들을 한번 적어보고 싶습니다!

이번 주차에서는 다음과 같은 고민들을 주로 했습니다.
- 검증은 누구의 책임일까?
- 도메인, 어떻게 작성할까?
- 횡단관심사를 분리하는 방법


## 검증은 누구의 책임일까?

지난 1, 2주차에서는 도메인 관련 검증도 외부 검증 객체를 빼서 처리했습니다. 도메인이 자신의 역할과 로직에 좀 더 충실하면 좋겠다는 생각에서 그렇게 처리했습니다.
하지만 이번 주차에서 레포를 포크해보니까, 검증이 Lotto 도메인 내부에 선언되어 있었습니다. 제가 짰던 코드들과 다른 구조에 당황했고, 검증을 어디에서 처리하는게 더 좋을까 라는 고민이 시작되었습니다.

제가 짜왔던 코드(외부에서 검증하는 방법)은 다음과 같은 장단점을 가지고 있었습니다.

- 장점
  - 보일러플레이트 검증을 줄일 수 있습니다.(null체크 등)
  - 도메인이 자신의 기능에 좀 더 충실할 수 있습니다. 여기서 말하는 기능은 비즈니스를 처리하기 위한 주요 로직들입니다.
  - 모든 입력 예외가 검증 객체에서 발생하기 때문에, 예외 처리 및 트랜잭션 관리에 좀 더 수월합니다. (!!)
- 단점
  - 검증로직 자체가 도메인과 밀접해있는 경우, 도메인의 응집도가 떨어집니다. 여기에 더해 도메인 세부 구현 사항이 노출됩니다.
  - 도메인이 자기 자신도 검증하지 못하게 됩니다. 만약 해당 도메인을 다른 코드에서 사용하고 싶다면, 무조건 검증 객체를 지나야 하기 때문에 재사용성도 떨어집니다.

시간을 들여 고민하여 이런 장단점을 명확하게 인지하고 나니, 코드의 구성 방법이 좀 더 명확해졌습니다.

"간단/반복되는 검증이나 IO에 닿아있는 검증은 따로 처리하고, 도메인과 닿아있는 검증은 도메인이 처리하자."

그렇게 짜인 코드는 다음과 같은 느낌으로 분리되었습니다.

- 도메인들의 검증
  - 로또 번호는 1~45사이이다.
  - 구매 금액은 1000원 단위이다.
  - ...
- IO계층의 검증
  - 숫자 값을 입력받을 때는 입력이 숫자 형식이어야 한다.  
  - 리스트 값을 입력받을 때는 입력이 리스트 형식이어야 한다.
- 외부 검증 객체의 검증
  - 파라미터로 전달된 값들은 null이면 안된다.

이렇게 검증하니, 오히려 역할이 더 잘 분리되었다는 느낌이 들었습니다. 도메인은 도메인의 관심사를 직접 처리하고, IO 계층은 입출력에 관한 검증을 처리하고, 보일러플레이트 검증은 따로 검증될 수 있습니다.
도메인의 응집도도 높이면서 역할을 확실하게 분리한 지금의 검증 방식이 마음에 들고, 큰 피드백 리뷰가 없다면 4주차에서도 그대로 가져가고 싶은 아키텍쳐입니다.


## 도메인, 어떻게 작성할까?

이번 주차에서는 1, 2주차에 비해 도메인이 더 많은 기능들을 해야 했습니다. 즉, 도메인주도설계를 마음껏 써먹어볼 수 있는 기회였습니다.
하지만 도메인을 위주로 개발한다는게 추상적이라서, 정확히 어떤 지침들을 따라야 하는지 헷갈렸습니다.
여러 글들을 읽고 고민한 결과, 다음과 같은 기준을 세우고 개발할 수 있었습니다.

1. 도메인은 다른 도메인 외에 그 어떠한 의존성도 가지지 않는다.
2. 도메인은 스스로를 검증하고, 적절한 상태를 유지할 수 있도록 한다.
3. 도메인은 비즈니스에 필요한 인터페이스를 제공하며, 그 외의 기능은 전부 감춘다.
4. 컨트롤러가 얇게 구성되어야 도메인이 더 많은 일을 할 수 있기 때문에, 컨트롤러를 최대한 얇게 구성한다.

이 지침들을 지키며 개발하니, 확실히 도메인이 더 풍부해질 수 있었고 단단해졌습니다! 컨트롤러에서 도메인들이 서로 협력하며 원하는 결과를 만들어내는 과정이 아주 마음에 들었습니다. 이 지침들도 계속해서 따르며 가져가고 싶습니다.


## 횡단관심사를 분리하는 방법

검증로직을 도메인에서 처리하니, IO로직과 도메인로직이 같이 재시도되어야 했고, 하나의 똑똑한 컨트롤러 안에서 도메인과 IO가 같이 재시도되는 코드가 탄생했습니다.
저는 이 코드가 매우 맘에 들지 않았는데,
첫번째로 확장성이 0였습니다. 재시도 로직말고, 다른 기능이 추가된다면 어떻게 하지? 또 컨트롤러에 작성해야 하나? 같은 의문이 들었습니다. 기능을 추가하는 것에 컨트롤러 코드가 수정되는 것은 OCP를 지키지 못하는 꼴이라고 생각했고, 원하는 기능을 넣었다 뺐다 끼워넣을 수 있는 유연한 코드를 작성하고 싶었습니다.
두번째로 재시도가 컨트롤러의 관심사인가? 라는 의문이 들었습니다. 재시도기능은 애플리케이션 전반에 걸친 횡단 관심사이고, 이를 따로 뽑아서 횡단 관심사만을 처리하는 어떠한 객체가 있으면 좋겠다고 생각했습니다.

스프링 AOP를 사용할 수 있다면 매우 편하겠지만, 스프링 없이 이런 횡단관심사를 처리하는 방법은 자바 리플렉션이 거의 유일무이하게 존재하는 듯 했습니다.
하지만 자바 리플렉션에 대한 이해가 부족했고, 무엇보다 리플렉션같은 기능을 사용하기 보다 설계만으로 해결할 수 있는 지점이지 않을까? 라는 생각에 정말 여러 아키텍쳐를 두고 고민했습니다.

고민의 결과로 파사드 패턴과 프록시 패턴을 함께 사용하게 되었습니다. 컨트롤러 파사드가 각각의 컨트롤러를 호출하고, 각각의 컨트롤러는 자신의 기능을 수행합니다.
이때, 만약 재시도가 필요한 부분이 있다면 재시도 프록시를 컨트롤러 파사드와 컨트롤러 사이에 구성할 수 있도록 설계했습니다. 이를 통해 만약 다른 횡단 관심사가 생긴다면 해당 프록시를 만들고 끼워넣기만 하면 되도록 하였습니다. 이를 통해 OCP를 좀 더 잘 지키는 코드가 탄생했고, 이 설계를 그대로 가져가서 4주차에서 다른 횡단 관심사를 끼워넣어보고 싶습니다!


---

# 짧디 짧은 소감

2주차에서는 정말 많은 분들에게 리뷰를 요청해서 코멘트를 159개나 받았습니다. 오랜 시간을 고민한 보람이 있는 기분좋은 리뷰들도 있었고, 제가 놓치고 있던 부분을 지적해주시는 리뷰들도 있었습니다. 특히 검증에 대한 부분은 제가 완전히 놓치고 있던 부분이라고 생각해서 신경써서 작성했습니다. 리뷰를 통해 고민하고 고민을 통해 성장하는 일주일이었던 것 같아서 행복합니다.
프리코스에서 정말 계속해서 배워나가는 것 같습니다! README와 PR을 다른 사람이 읽게 쉽게 작성하는 방법, 도메인과 외부 의존성에 대한 고민들, 새로운 지식과 무지를 대하는 태도까지. 저에게는 개발 실력 뿐만 아니라 소프트 스킬까지 챙길 수 있는 시간이 되고 있습니다. 이제 4주차 과제 하나만 남았는데, 부디 더더더 어려운 과제가 나와서 좋은 고민들을 하고 많은 경험을 쌓을 수 있기를 진심으로 바라고 있습니다.